{
  "author": {
    "name": "Dan Dean",
    "email": "@dandean",
    "url": "http://dandean.com"
  },
  "name": "express-form",
  "description": "Form validation and data filtering for Express",
  "version": "0.12.0",
  "homepage": "http://dandean.github.com/express-form",
  "repository": {
    "type": "git",
    "url": "git://github.com/freewil/express-form.git"
  },
  "contributors": [
    {
      "name": "Marc Harter",
      "email": "wavded@gmail.com"
    },
    {
      "name": "Sugarstack",
      "email": "@sugarstack"
    },
    {
      "name": "Sean Lavine",
      "email": "sean@eternalrise.com"
    }
  ],
  "keywords": [
    "form",
    "validator",
    "validation",
    "express"
  ],
  "dependencies": {
    "validator": "0.4.x",
    "object-additions": ">= 0.5.0",
    "async": "~0.2.9"
  },
  "peerDependencies": {
    "express": "3.x"
  },
  "devDependencies": {
    "mocha": "~1.13.0",
    "express": "3.x",
    "request": "~2.27.0"
  },
  "main": "index",
  "bugs": {
    "url": "http://github.com/freewil/express-form/issues"
  },
  "scripts": {
    "test": "mocha"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/freewil/express-form/raw/master/LICENSE"
    }
  ],
  "readme": "# express-form\n\nExpress Form provides data filtering and validation as route middleware to your Express applications.\n\n[![Build Status](https://travis-ci.org/freewil/express-form.png?branch=master)](https://travis-ci.org/freewil/express-form)\n\n## Install\n\n* **Express 2.x** `npm install express-form@0.9.x`\n\n* **Express 3.x** `npm install express-form@0.10.x`\n\n## Usage\n\n```js\nvar express = require('express'),\n    form = require('express-form'),\n    field = form.field;\n    \nvar app = express();\n\napp.configure(function() {\n  app.use(express.bodyDecoder());\n  app.use(app.router);\n});\n\napp.post(\n\n  // Route\n  '/user',\n      \n  // Form filter and validation middleware\n  form(\n    field(\"username\").trim().required().is(/^[a-z]+$/),\n    field(\"password\").trim().required().is(/^[0-9]+$/),\n    field(\"email\").trim().isEmail()\n   ),\n      \n   // Express request-handler now receives filtered and validated data\n   function(req, res){\n     if (!req.form.isValid) {\n       // Handle errors\n       console.log(req.form.errors);\n\n     } else {\n       // Or, use filtered form data from the form object:\n       console.log(\"Username:\", req.form.username);\n       console.log(\"Password:\", req.form.password);\n       console.log(\"Email:\", req.form.email);\n     }\n  }\n);\n\napp.listen(3000);\n```\n\n## Documentation\n\n### Module\n\n`express-form` returns an `express` [Route Middleware](http://expressjs.com/guide.html#Route-Middleware) function. \nYou specify filtering and validation by passing filters and validators as \narguments to the main module function. For example:\n\n```js\nvar form = require(\"express-form\");\n\napp.post('/user',\n\n  // Express Form Route Middleware: trims whitespace off of\n  // the `username` field.\n  form(form.field(\"username\").trim()),\n  \n  // standard Express handler\n  function(req, res) {\n    // ...\n  }\n);\n```\n\n### Fields\n\nThe `field` property of the module creates a filter/validator object tied to a specific field.\n\n```\nfield(fieldname[, label]);\n```\n\nYou can access nested properties with either dot or square-bracket notation.\n\n```js\nfield(\"post.content\").minLength(50),\nfield(\"post[user][id]\").isInt(),\nfield(\"post.super.nested.property\").required()\n```\n\nSimply specifying a property like this, makes sure it exists. So, even if `req.body.post` was undefined, \n`req.form.post.content` would be defined. This helps avoid any unwanted errors in your code.\n\nThe API is chainable, so you can keep calling filter/validator methods one after the other:\n\n```js\nfilter(\"username\")\n  .required()\n  .trim()\n  .toLower()\n  .truncate(5)\n  .isAlphanumeric()\n```\n\n### Filter API:\n\nType Coercion\n\n    toFloat()           -> Number\n\n    toInt()             -> Number, rounded down\n\n    toBoolean()         -> Boolean from truthy and falsy values\n\n    toBooleanStrict()   -> Only true, \"true\", 1 and \"1\" are `true`\n\n    ifNull(replacement) -> \"\", undefined and null get replaced by `replacement`\n    \n\nHTML Encoding for `& \" < >`\n\n    entityEncode() -> encodes HTML entities\n\n    entityDecode() -> decodes HTML entities \n\n\nString Transformations\n\n    trim(chars)                 -> `chars` defaults to whitespace\n\n    ltrim(chars)\n\n    rtrim(chars)\n\n    toLower() / toLowerCase()\n\n    toUpper() / toUpperCase()\n\n    truncate(length)            -> Chops value at (length - 3), appends `...`\n    \n\n### Validator API:\n\n**Validation messages**: each validator has its own default validation message. \nThese can easily be overridden at runtime by passing a custom validation message \nto the validator. The custom message is always the **last** argument passed to \nthe validator. `required()` allows you to set a placeholder (or default value)\nthat your form contains when originally presented to the user. This prevents the\nplaceholder value from passing the `required()` check.\n\nUse \"%s\" in the message to have the field name or label printed in the message:\n\n    validate(\"username\").required()\n    // -> \"username is required\"\n    \n    validate(\"username\").required(\"Type your desired username\", \"What is your %s?\")\n    // -> \"What is your username?\"\n    \n    validate(\"username\", \"Username\").required(\"\", \"What is your %s?\")\n    // -> \"What is your Username?\"\n\n\n**Validation Methods**\n\n*By Regular Expressions*\n\n    regex(pattern[, modifiers[, message]])\n    - pattern (RegExp|String): RegExp (with flags) or String pattern.\n    - modifiers (String): Optional, and only if `pattern` is a String.\n    - message (String): Optional validation message.\n    \n        alias: is\n\n        Checks that the value matches the given regular expression.\n    \n        Example:\n\n        validate(\"username\").is(\"[a-z]\", \"i\", \"Only letters are valid in %s\")\n        validate(\"username\").is(/[a-z]/i, \"Only letters are valid in %s\")\n    \n    \n    notRegex(pattern[, modifiers[, message]])\n    - pattern (RegExp|String): RegExp (with flags) or String pattern.\n    - modifiers (String): Optional, and only if `pattern` is a String.\n    - message (String): Optional validation message.\n    \n        alias: not\n\n        Checks that the value does NOT match the given regular expression.\n    \n        Example:\n\n        validate(\"username\").not(\"[a-z]\", \"i\", \"Letters are not valid in %s\")\n        validate(\"username\").not(/[a-z]/i, \"Letters are not valid in %s\")\n\n\n*By Type*\n\n    isNumeric([message])\n\n    isInt([message])\n\n    isDecimal([message])\n\n    isFloat([message])\n\n\n*By Format*\n\n    isDate([message])\n\n    isEmail([message])\n\n    isUrl([message])\n\n    isIP([message])\n\n    isAlpha([message])\n\n    isAlphanumeric([message])\n\n    isLowercase([message])\n\n    isUppercase([message])\n\n\n*By Content*\n\n    notEmpty([message])\n    \n        Checks if the value is not just whitespace.\n        \n\n    equals( value [, message] )\n    - value (String): A value that should match the field value OR a fieldname\n                      token to match another field, ie, `field::password`.\n        \n        Compares the field to `value`.\n    \n        Example:\n        validate(\"username\").equals(\"admin\")\n\n        validate(\"password\").is(/^\\w{6,20}$/)\n        validate(\"password_confirmation\").equals(\"field::password\")\n\n\n    contains(value[, message])\n    - value (String): The value to test for.\n        \n        Checks if the field contains `value`.\n        \n\n    notContains(string[, message])\n    - value (String): A value that should not exist in the field.\n\n        Checks if the field does NOT contain `value`.\n\n\n*Other*\n    \n    required([message])\n    \n        Checks that the field is present in form data, and has a value.\n        \n### Array Method\n\n    array()\n        Using the array() flag means that field always gives an array. If the field value is an array, but there is no flag, then the first value in that array is used instead.\n\n        This means that you don't have to worry about unexpected post data that might break your code. Eg/ when you call an array method on what is actually a string.\n\n        field(\"project.users\").array(),\n        // undefined => [], \"\" => [], \"q\" => [\"q\"], [\"a\", \"b\"] => [\"a\", \"b\"]\n\n        field(\"project.block\"),\n        // project.block: [\"a\", \"b\"] => \"a\". No \"array()\", so only first value used.\n\n        In addition, any other methods called with the array method, are applied to every value within the array.\n\n        field(\"post.users\").array().toUpper()\n        // post.users: [\"one\", \"two\", \"three\"] => [\"ONE\", \"TWO\", \"THREE\"]\n\n### Custom Methods\n\n    custom(function[, message])\n    - function (Function): A custom filter or validation function.\n\n        This method can be utilised as either a filter or validator method.\n\n        If the function throws an error, then an error is added to the form. (If `message` is not provided, the thrown error message is used.)\n\n        If the function returns a value, then it is considered a filter method, with the field then becoming the returned value.\n\n        If the function returns undefined, then the method has no effect on the field.\n    \n        Examples:\n\n        If the `name` field has a value of \"hello there\", this would\n        transform it to \"hello-there\". \n\n        field(\"name\").custom(function(value) {\n          return value.replace(/\\s+/g, \"-\");\n        });\n\n        Throws an error if `username` field does not have value \"admin\".\n        \n        field(\"username\").custom(function(value) {\n            if (value !== \"admin\") {\n                throw new Error(\"%s must be 'admin'.\");\n            }\n        });\n        \n        Validator based value on another field of the incoming source being validated\n        \n        field(\"sport\", \"favorite sport\").custom(function(value, source) {\n          if (!source.country) {\n            throw new Error('unable to validate %s');\n          }\n          \n          switch (source.country) {\n            case 'US':\n              if (value !=== 'baseball') {\n                throw new Error('America likes baseball');\n              }\n              break;\n              \n            case 'UK':\n              if (value !=== 'football') {\n                throw new Error('UK likes football');\n              }\n              break;\n          }\n          \n        });\n        \n        Asynchronous custom validator (3 argument function signature)\n        \n        form.field('username').custom(function(value, source, callback) {\n          username.check(value, function(err) {\n            if (err) return callback(new Error('Invalid %s'));\n            callback(null);\n          });\n        });\n    \n\n### http.ServerRequest.prototype.form\n\nExpress Form adds a `form` object with various properties to the request.\n\n    isValid -> Boolean\n\n    errors  -> Array\n\n    flashErrors(name) -> undefined\n    \n        Flashes all errors. Configurable, enabled by default.\n\n    getErrors(name) -> Array or Object if no name given\n    - fieldname (String): The name of the field\n    \n        Gets all errors for the field with the given name.\n\n        You can also call this method with no parameters to get a map of errors for all of the fields.\n\n    Example request handler:\n    \n    function(req, res) {\n      if (!req.form.isValid) {\n        console.log(req.errors);\n        console.log(req.getErrors(\"username\"));\n        console.log(req.getErrors());\n      }\n    }\n\n### Configuration\n\nExpress Form has various configuration options, but aims for sensible defaults for a typical Express application.\n\n    form.configure(options) -> self\n    - options (Object): An object with configuration options.\n\n    flashErrors (Boolean): If validation errors should be automatically passed to Express’ flash() method. Default: true.\n\n    autoLocals (Boolean): If field values from Express’ request.body should be passed into Express’ response.locals object. This is helpful when a form is invalid an you want to repopulate the form elements with their submitted values. Default: true.\n\n    Note: if a field name dash-separated, the name used for the locals object will be in camelCase.\n\n    dataSources (Array): An array of Express request properties to use as data sources when filtering and validating data. Default: [\"body\", \"query\", \"params\"].\n\n    autoTrim (Boolean): If true, all fields will be automatically trimmed. Default: false.\n\n    passThrough (Boolean): If true, all data sources will be merged with `req.form`. Default: false.\n\n\n### Credits\n\nCurrently, Express Form uses many of the validation and filtering functions provided by Chris O'Hara's [node-validator](https://github.com/chriso/node-validator).\n",
  "readmeFilename": "README.md",
  "_id": "express-form@0.12.0",
  "_from": "express-form@latest"
}
